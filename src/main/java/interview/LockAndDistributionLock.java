package interview;

/**
 * @author KCWang
 * @version 1.0 分布式锁
 *
 * 题记：分布式锁三种实现方式：
 * 基于数据库实现分布式锁；
 * 基于缓存（Redis等）实现分布式锁（AP）
 * 基于Zookeeper实现分布式锁（CP）。
 * 从性能角度（从高到低）来看：“缓存方式>Zookeeper方式>=数据库方式”。
 *
 * 说起分布式的概念，首当其冲就是CAP理论，即满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）。但是CAP理论告诉我们，任何系统只能满足其中两个。
 * 一、数据库实现分布式锁
 * 1. 悲观锁
 *
 * 利用select … where … for update 排他锁。阻塞的，容易锁表。
 *
 * 2. 乐观锁
 *
 * update version通过增加递增的版本号字段实现乐观锁。
 *
 * 3、 基于数据库表获取
 * 获取锁时，只要执行insert语句
 * insert into lock_table(“method_name”,“time”)；
 * 释放锁，delete
 * 当然还有其他许多问题需要解决，可重入、定时扫描过期时间等
 *
 * 二、Redis分布式锁
 * 1、简化版setnx命令：
 *
 * if (jedis.setnx(lockKey, val) == 1) { jedis.expire(lockKey, timeout);}
 * 很显然，加锁操作和后面的设置超时时间是分开的，并非原子操作。假如加锁成功，但是设置超时时间失败了，该lockKey就变成永不失效。
 *
 * 2、set(lockKey, requestId, "NX", "PX", expireTime)命令，该命令可以指定多个参数。
 *
 * String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);if ("OK".equals(result)) {return true;}return false;
 * 其中：
 * lockKey：锁的标识
 * requestId：请求id
 * NX：只在键不存在时，才对键进行设置操作。
 * PX：设置键的过期时间为 millisecond 毫秒。
 * expireTime：过期时间
 * 满足了原子性，但是每次都要达到了超时时间才释放锁，显然也不是很合理，那么如何手工释放锁？
 *
 * 3、finally中释放锁+全局唯一标识
 *
 * try{ String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime); if ("OK".equals(result)) { return true; } return false; }
 * finally { if (jedis.get(lockKey).equals(requestId)) { jedis.del(lockKey); return true; } return false; }
 * 无论代码执行成功或失败了，都需要释放锁。如果有异常了，到达超时时间，锁还是会被redis自动释放。
 * 而requestId是全局唯一的，保证了自己只能释放自己加的锁，不存在加锁和释放别人锁的情况。
 *
 * 4、Redis+Lua
 *
 * Redis+Lua，可以说是专门为解决原子问题而生。Lua专门整合原子操作。有了 Lua 的特性，Redis 才真正在分布式锁、秒杀等场景，有了用武之地。
 * 为什么要用Lua脚本呢？因为一段复杂的业务逻辑，可以通过封装在Lua脚本中发送给Redis，保证这段复杂业务逻辑执行的原子性。
 *
 * 5、看门狗
 * 如果锁达到了超时时间，但业务代码还没执行完怎么办？
 * 看门狗可以通过定时任务不断刷新锁的获取事件，从而在用户获取锁到释放锁期间保持一直持有锁。
 *
 * eg:我们可以使用TimerTask类，来实现自动续期的功能：获取锁之后，自动开启一个定时任务，每隔10秒钟，自动刷新一次过期时间。这种机制就是redisson框架中的watch dogTimer timer = new Timer();
 * timer.schedule(new TimerTask() { @Overridepublicvoidrun(Timeout timeout)throws Exception { //自动续期逻辑 } }, 10000, TimeUnit.MILLISECONDS);
 * 三、基于Zookeeper实现分布式锁
 * ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：
 *
 * （1）创建一个目录mylock；
 * （2）线程A想获取锁就在mylock目录下创建临时顺序节点；
 * （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
 * （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
 * （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
 * 通常使用ZooKeeper的一个客户端Curator，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。
 *
 * 四、总结（优缺点）
 * 数据库锁：
 *
 * db操作性能较差，并且有锁表的风险
 * 非阻塞操作失败后，需要轮询，占用cpu资源;
 * redis分布式锁:
 *
 * 主从切换的情况下可能出现多客户端获取锁的情况；
 * Lua脚本在单机上具有原子性，主从同步时不具有原子性
 * 基于Zookeeper的分布式锁：
 *
 * 需要引入Zookeeper集群，比较重量级；
 * 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。
 * 因为需要频繁的创建和删除节点，性能上不如Redis方式。
 * 小结：
 * 如果你的实际业务场景，更需要的是保证数据一致性。那么请使用CP类型的分布式锁，比如：zookeeper
 * 如果你的实际业务场景，更需要的是保证数据高可用性。那么请使用AP类型的分布式锁，比如：redis；
 * 通常redis足够用了，通过最终一致性大部分即可满足需求了，强一致性实时数据还是要依赖数据库的事务。
 *
 * Synchronized的使用方式
 *      1.当synchronized修饰非静态方法时，锁住的是当前调用该方法的实例对象
 *             如果此时非单例调用，会导致锁失效！
 *
 *      2.当synchronized修饰的是非静态代码块，则锁住的是括号里面的实例对象
 *
 *      3.当synchronized修饰的是静态方法或者静态代码块时，则锁住的是类对象，因为不管一个class被
 *
 *      实例化多少次，静态方法和静态代码块在jvm中只会存在一份，因此当此类的所有实例对象在调用静态方法
 *
 *      或者静态代码块时共用同一把锁，因此也称为类锁
 *
 * Synchronized的底层原理
 *      synchronized是基于JVM内置锁实现的，通过内部对象Monitor（监视器锁）实现，基于进入和退出Monitor对
 *
 *      象来实现方法和代码块的同步。这是一个重量级锁，性能偏低。
 *
 *      Java1.5版本之后做了很大的变化，比如锁粗化，锁消除，偏向锁，轻量级锁，适应性自旋锁等技术来减少操作
 *
 *      的开销。synchronized性能已经有很大的提升了，已基本和Lock持平。
 *
 *      每个对象都有一个自己的Monitor监视器锁
 *
 *      锁的膨胀升级过程
 *
 * Java对象在内存中的存储方案
 *
 *      HotSpot虚拟机中，对象在内存中被划分成三块区域存储:
 *
 *      1.对象头:比如hash码，对象所属的年代，对象锁，锁标识，偏向锁(线程)ID等。
 *
 *      2.实例数据：即创建对象时，对象中的成员变量，方法等。
 *
 *      3.对象填充：对象的大小必须是8字节的整数倍
 *
 *
 * 锁的状态总共有四种，无锁，偏向锁，轻量级锁，重量级锁。随着多个线程竞争共享资源，锁可以从偏向锁升级到
 *
 * 轻量级锁，再升级到重量级锁，而且这个过程是单向的，不可逆的。也就说锁只能从低到高升级，而不会出现锁降级。
 *
 * 偏向锁
 *
 *      偏向锁时jdk1.6之后加入的新锁，它是一种针对加锁操作的优化手段。经研究发现，大多数情况下，锁不仅不存在
 *
 *      多线程竞争，而写总是由同一线程多次获得锁，因此为了减少同一线程获取锁时进行的一些CAS操作而消耗一定的性能而
 *
 *      引入偏向锁。
 *
 *      偏向锁的核心思想是，如果一个线程获取了锁，那么锁就进入偏向该线程的模式，此时对象的Mark Word结构也
 *
 *      会变为偏向锁结构，当这个线程再次申请该锁时，无需做任何操作，即可获得该锁的使用权，这样就省去了大量的有关
 *
 *      申请锁的操作，从而提高程序的性能。
 *
 *      偏向锁的适用场景是对于锁的竞争不是很激烈的场合。
 *
 *      偏向锁失败后，不会立即升级为重量级锁，而是变成轻量级锁。
 *
 *  轻量级锁
 *
 *      从偏向锁升级成轻量级锁后，对象的Mark Word也会发生变化.
 *
 *      轻量级锁的依据是：对加锁的整个周期内的绝大部分时间不存在竞争，另一个线程自旋等待锁资源释放，不会交出
 *
 *      CPU使用权。
 *
 *      轻量级锁的适用场景是多个线程交替执行同步块的情况，如果同一时间有多个线程竞争锁资源的话，就会升级成
 *
 *      重量级锁.
 *
 *  自旋锁
 *
 *      自旋锁的实现是进行一定次数的空循环，一般是50次或者100个循环，在经过若干次循环后，如果得到锁，进进入
 *
 *      临界区，如果还不能获取到锁，就会将线程在操作系统层面挂起。
 *
 *     锁消除
 *
 *      Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除
 *
 *      没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的
 *
 *      StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，
 *
 *      JVM会自动将其锁消除
 *
 * @date 2023/7/5 下午9:17
 */
public class LockAndDistributionLock {
}
